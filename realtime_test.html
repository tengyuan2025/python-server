<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>豆包实时语音对话</title>
    <!-- 添加pako库用于gzip压缩 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .config-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .config-item {
            flex: 1;
        }

        .config-item label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .config-item input, .config-item select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .status.disconnected {
            background: #ffebee;
            color: #c62828;
        }

        .status.connected {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status.recording {
            background: #fff3e0;
            color: #f57c00;
            animation: pulse 2s infinite;
        }

        .status.processing {
            background: #e3f2fd;
            color: #1976d2;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 150px;
        }

        #connectBtn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        #connectBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.4);
        }

        #startBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #startBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        #stopBtn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
        }

        #stopBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(238, 90, 82, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .visualizer {
            width: 100%;
            height: 120px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .results-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .results-title {
            font-size: 14px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clear-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #e0e0e0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: none;
            letter-spacing: normal;
            min-width: auto;
        }

        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }

        .message.user {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message.assistant {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
        }

        .message.tts {
            background: #fce4ec;
            border-left: 4px solid #e91e63;
        }

        .message.error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
        }

        .message-time {
            font-size: 11px;
            color: #999;
            float: right;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .audio-controls {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 8px;
        }

        .audio-controls audio {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎤 豆包实时语音对话</h1>
        
        <div class="config-panel">
            <div class="config-row">
                <div class="config-item">
                    <label>代理服务器状态</label>
                    <input type="text" id="proxyStatus" value="使用本地代理 ws://localhost:8765" readonly style="background:#e8f5e8;">
                </div>
                <div class="config-item">
                    <label>认证信息</label>
                    <input type="text" id="authInfo" value="已在代理服务器配置" readonly style="background:#e8f5e8;">
                </div>
            </div>
            <div class="config-row">
                <div class="config-item">
                    <label>音色选择</label>
                    <select id="speaker">
                        <option value="zh_female_vv_jupiter_bigtts">vv (活泼女声)</option>
                        <option value="zh_female_xiaohe_jupiter_bigtts">xiaohe (甜美女声)</option>
                        <option value="zh_male_yunzhou_jupiter_bigtts">yunzhou (沉稳男声)</option>
                        <option value="zh_male_xiaotian_jupiter_bigtts">xiaotian (磁性男声)</option>
                    </select>
                </div>
                <div class="config-item">
                    <label>输出格式</label>
                    <select id="audioFormat">
                        <option value="pcm" selected>PCM 24000Hz Float32 (推荐)</option>
                        <option value="pcm_s16le">PCM 24000Hz 16bit</option>
                        <option value="opus">Opus</option>
                    </select>
                </div>
            </div>
            <div class="config-row">
                <div class="config-item">
                    <label>机器人名称</label>
                    <input type="text" id="botName" value="豆包" placeholder="机器人名称">
                </div>
                <div class="config-item">
                    <label>对话 ID (可选)</label>
                    <input type="text" id="dialogId" placeholder="用于续接之前的对话">
                </div>
            </div>
        </div>
        
        <div class="status disconnected" id="status">未连接</div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="duration">0s</div>
                <div class="stat-label">对话时长</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="turns">0</div>
                <div class="stat-label">对话轮次</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="tokens">0</div>
                <div class="stat-label">Token 使用</div>
            </div>
        </div>
        
        <div class="visualizer">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="connectBtn">连接服务</button>
            <button id="startBtn" disabled>开始对话</button>
            <button id="stopBtn" disabled>结束对话</button>
        </div>
        
        <div class="results-container">
            <div class="results-panel">
                <div class="results-title">
                    识别结果 (ASR)
                    <button class="clear-btn" onclick="clearASR()">清空</button>
                </div>
                <div id="asr-results"></div>
            </div>
            <div class="results-panel">
                <div class="results-title">
                    对话内容 (Chat)
                    <button class="clear-btn" onclick="clearChat()">清空</button>
                </div>
                <div id="chat-results"></div>
            </div>
        </div>
        
        <div class="audio-controls" style="display:none;" id="audioControls">
            <audio id="audioPlayer" controls></audio>
        </div>
    </div>

    <script>
        // 配置常量
        // 使用本地代理服务器（代理服务器会处理认证）
        const WS_URL = 'ws://localhost:8765';
        const RESOURCE_ID = 'volc.speech.dialog';
        const APP_KEY = 'PlgvMymc7f3tQnJ6';
        
        // WebSocket和音频相关变量
        let ws = null;
        let audioContext = null;
        let mediaRecorder = null;
        let analyser = null;
        let microphone = null;
        let isRecording = false;
        let sessionId = null;
        let connectId = null;
        let sequenceNumber = 0;
        
        // 统计变量
        let startTime = null;
        let turnCount = 0;
        let totalTokens = 0;
        
        // 音频缓冲（移除重复声明）
        // let audioQueue = []; // 已在下面声明
        // let isPlaying = false; // 改名为isAudioPlaying
        
        // DOM 元素
        const connectBtn = document.getElementById('connectBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const asrResults = document.getElementById('asr-results');
        const chatResults = document.getElementById('chat-results');
        const canvas = document.getElementById('canvas');
        const canvasContext = canvas.getContext('2d');
        
        // 初始化Canvas
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        // 生成UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // 更新状态
        function updateStatus(statusClass, message) {
            statusDiv.className = `status ${statusClass}`;
            statusDiv.textContent = message;
        }
        
        // 导入pako库用于gzip压缩（添加到HTML head部分）
        
        // 构建二进制协议帧（按照官方示例实现）
        function buildBinaryFrame(messageType, eventId, payload, sessionIdStr = null) {
            // Header: 4 bytes
            const header = new Uint8Array(4);
            header[0] = 0x11; // Protocol version (0x1) + Header size (0x1)
            header[1] = (messageType << 4) | 0x04; // Message type + event flag
            
            // 设置序列化和压缩方式（根据官方示例）
            if (typeof payload === 'string') {
                header[2] = 0x11; // JSON serialization + GZIP compression
            } else {
                header[2] = 0x01; // Raw + GZIP compression (音频数据也需要压缩)
            }
            header[3] = 0x00; // Reserved
            
            // Optional fields按顺序构建
            let optional = new Uint8Array(0);
            
            // Event ID (4 bytes)
            const eventBytes = new Uint8Array(4);
            const eventView = new DataView(eventBytes.buffer);
            eventView.setUint32(0, eventId, false); // big-endian
            optional = new Uint8Array([...optional, ...eventBytes]);
            
            // Session ID (对于Session级别的事件)
            if (sessionIdStr && eventId >= 100 && eventId < 600) {
                const sessionBytes = new TextEncoder().encode(sessionIdStr);
                const sizeBytes = new Uint8Array(4);
                const sizeView = new DataView(sizeBytes.buffer);
                sizeView.setUint32(0, sessionBytes.length, false);
                optional = new Uint8Array([...optional, ...sizeBytes, ...sessionBytes]);
            }
            
            // Payload处理和压缩
            let payloadBytes;
            if (typeof payload === 'string') {
                // JSON数据先编码再压缩
                const jsonBytes = new TextEncoder().encode(payload);
                payloadBytes = gzipCompress(jsonBytes);
            } else if (payload instanceof Uint8Array) {
                // 音频数据也需要压缩（按照官方示例）
                payloadBytes = gzipCompress(payload);
            } else {
                const emptyJson = new TextEncoder().encode('{}');
                payloadBytes = gzipCompress(emptyJson);
            }
            
            // Payload size (4 bytes)
            const payloadSize = new Uint8Array(4);
            const payloadView = new DataView(payloadSize.buffer);
            payloadView.setUint32(0, payloadBytes.length, false);
            
            // Combine all parts
            const result = new Uint8Array([...header, ...optional, ...payloadSize, ...payloadBytes]);
            
            console.log(`构建帧: 消息类型=${messageType.toString(16)}, 事件ID=${eventId}, 压缩后负载=${payloadBytes.length}bytes, 总长度=${result.length}`);
            
            return result;
        }
        
        // 简单的gzip压缩实现
        function gzipCompress(data) {
            // 使用pako库进行gzip压缩
            // 如果没有pako库，可以先返回原数据，但这会导致协议不匹配
            if (typeof pako !== 'undefined') {
                return pako.gzip(data);
            } else {
                console.warn('pako库未加载，使用未压缩数据（可能导致协议错误）');
                return data;
            }
        }
        
        // 解析二进制帧
        function parseBinaryFrame(data) {
            // 确保data是ArrayBuffer
            let buffer;
            if (data instanceof ArrayBuffer) {
                buffer = data;
            } else if (data.buffer instanceof ArrayBuffer) {
                buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            } else {
                console.error('Invalid data type for binary frame:', typeof data);
                return null;
            }
            
            const view = new DataView(buffer);
            let offset = 0;
            
            // Parse header
            const byte0 = view.getUint8(offset++);
            const byte1 = view.getUint8(offset++);
            const byte2 = view.getUint8(offset++);
            const byte3 = view.getUint8(offset++);
            
            const messageType = (byte1 >> 4) & 0x0F;
            const flags = byte1 & 0x0F;
            
            // Parse optional fields
            let eventId = null;
            let sessionId = null;
            let errorCode = null;
            
            // Error code (if error frame)
            if (messageType === 0x0F) {
                errorCode = view.getUint32(offset, false);
                offset += 4;
            }
            
            // Event ID
            if (flags & 0x04) {
                eventId = view.getUint32(offset, false);
                offset += 4;
            }
            
            // Session ID
            if (eventId >= 100 && eventId < 600) {
                const sessionIdSize = view.getUint32(offset, false);
                offset += 4;
                const sessionIdBytes = new Uint8Array(data.slice(offset, offset + sessionIdSize));
                sessionId = new TextDecoder().decode(sessionIdBytes);
                offset += sessionIdSize;
            }
            
            // Payload size and payload
            const payloadSize = view.getUint32(offset, false);
            offset += 4;
            
            let payload = null;
            if (payloadSize > 0) {
                const payloadBytes = new Uint8Array(data.slice(offset, offset + payloadSize));
                
                // Check if it's JSON (text) or binary
                if (messageType === 0x09 || messageType === 0x0F) { // Server response or error
                    try {
                        payload = JSON.parse(new TextDecoder().decode(payloadBytes));
                    } catch {
                        payload = payloadBytes;
                    }
                } else if (messageType === 0x0B) { // Audio response
                    payload = payloadBytes;
                }
            }
            
            return {
                messageType,
                flags,
                eventId,
                sessionId,
                errorCode,
                payload
            };
        }
        
        // 连接WebSocket
        function connectWebSocket() {
            // 连接到本地代理服务器（代理服务器已配置认证信息）
            connectId = generateUUID();
            
            // 直接连接本地代理
            ws = new WebSocket(WS_URL);
            ws.binaryType = 'arraybuffer';
            
            ws.onopen = () => {
                console.log('WebSocket连接已建立');
                updateStatus('connected', 'WebSocket已连接');
                
                // 发送StartConnection事件
                const frame = buildBinaryFrame(0x01, 1, '{}');
                ws.send(frame);
                
                connectBtn.textContent = '断开连接';
                connectBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
                startBtn.disabled = false;
            };
            
            ws.onmessage = (event) => {
                // 检查消息类型
                if (typeof event.data === 'string') {
                    // JSON消息（代理服务器的状态消息）
                    try {
                        const jsonData = JSON.parse(event.data);
                        if (jsonData.type === 'proxy_connected') {
                            console.log('代理服务器连接确认:', jsonData.message);
                            addMessage('系统', jsonData.message, 'assistant');
                        } else if (jsonData.type === 'proxy_error') {
                            console.error('代理服务器错误:', jsonData.error);
                            addMessage('错误', jsonData.error, 'error');
                        }
                    } catch (e) {
                        console.error('解析JSON消息失败:', e);
                    }
                } else {
                    // 二进制消息（豆包API消息）
                    try {
                        const frame = parseBinaryFrame(event.data);
                        handleServerEvent(frame);
                    } catch (e) {
                        console.error('解析二进制帧失败:', e);
                    }
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket错误:', error);
                updateStatus('disconnected', 'WebSocket错误');
            };
            
            ws.onclose = () => {
                console.log('WebSocket连接已关闭');
                updateStatus('disconnected', '连接已断开');
                connectBtn.textContent = '连接服务';
                connectBtn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                startBtn.disabled = true;
                stopBtn.disabled = true;
                ws = null;
            };
        }
        
        // 处理服务器事件（按照官方示例逻辑）
        function handleServerEvent(frame) {
            if (!frame) {
                console.warn('接收到无效的帧数据');
                return;
            }
            
            const { eventId, payload, messageType } = frame;
            
            console.log('收到事件: messageType=', messageType?.toString(16), 'eventId=', eventId);
            
            // 按照官方示例：音频数据是SERVER_ACK类型（messageType = 0x0B）
            if (messageType === 0x0B && payload instanceof Uint8Array) {
                // 这是音频数据！直接播放
                console.log(`接收到音频数据: ${payload.length} 字节`);
                playAudio(payload);
                return;
            }
            
            // 处理其他事件
            switch (eventId) {
                case 50: // ConnectionStarted
                    addMessage('系统', '连接已建立', 'assistant');
                    break;
                    
                case 450: // ASRInfo - 用户开始说话，清空音频缓存
                    console.log('检测到用户说话，清空音频队列');
                    audioQueue = []; // 清空音频队列
                    updateStatus('processing', '检测到语音');
                    break;
                    
                case 150: // SessionStarted
                    if (payload && payload.dialog_id) {
                        document.getElementById('dialogId').value = payload.dialog_id;
                    }
                    updateStatus('connected', '会话已开始');
                    addMessage('系统', '会话已开始', 'assistant');
                    break;
                    
                case 451: // ASRResponse
                    if (payload && payload.results && payload.results.length > 0) {
                        const result = payload.results[0];
                        displayASRResult(result.text, result.is_interim);
                    }
                    break;
                    
                case 459: // ASREnded
                    updateStatus('processing', '语音结束，等待回复...');
                    break;
                    
                case 350: // TTSSentenceStart
                    if (payload && payload.text) {
                        addMessage('豆包', payload.text, 'assistant');
                    }
                    break;
                    
                case 359: // TTSEnded
                    turnCount++;
                    document.getElementById('turns').textContent = turnCount;
                    updateStatus('recording', '等待您说话...');
                    
                    // 根据格式播放累积的音频
                    const currentFormat = document.getElementById('audioFormat').value;
                    if (currentFormat === 'opus' && isCollectingAudio) {
                        playCompleteOpusAudio();
                    }
                    break;
                    
                case 550: // ChatResponse
                    if (payload && payload.content) {
                        addMessage('豆包', payload.content, 'assistant');
                    }
                    break;
                    
                case 154: // UsageResponse
                    if (payload && payload.usage) {
                        const usage = payload.usage;
                        const total = (usage.input_text_tokens || 0) + 
                                     (usage.input_audio_tokens || 0) + 
                                     (usage.output_text_tokens || 0) + 
                                     (usage.output_audio_tokens || 0);
                        totalTokens += total;
                        document.getElementById('tokens').textContent = totalTokens;
                    }
                    break;
                    
                case 153: // SessionFailed
                case 51: // ConnectionFailed
                    if (payload && payload.error) {
                        addMessage('错误', payload.error, 'error');
                    }
                    break;
            }
        }
        
        // 开始会话
        async function startSession() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('请先连接WebSocket');
                return;
            }
            
            sessionId = generateUUID();
            
            // 构建StartSession payload
            const speaker = document.getElementById('speaker').value;
            const audioFormat = document.getElementById('audioFormat').value;
            const botName = document.getElementById('botName').value;
            const dialogId = document.getElementById('dialogId').value;
            
            // 按照官方示例配置（完整配置）
            const sessionConfig = {
                asr: {
                    extra: {
                        end_smooth_window_ms: 1500
                    }
                },
                tts: {
                    speaker: speaker,
                    audio_config: {
                        channel: 1,
                        format: audioFormat,
                        sample_rate: 24000
                    }
                },
                dialog: {
                    bot_name: botName || '豆包',
                    system_role: '你使用活泼灵动的女声，性格开朗，热爱生活。',
                    speaking_style: '你的说话风格简洁明了，语速适中，语调自然。',
                    location: {
                        city: '北京'
                    },
                    extra: {
                        strict_audit: false,
                        audit_response: '支持客户自定义安全审核回复话术。'
                    }
                }
            };
            
            // 如果有dialog_id，添加到配置中
            if (dialogId) {
                sessionConfig.dialog.dialog_id = dialogId;
            }
            
            // 发送StartSession事件
            const frame = buildBinaryFrame(
                0x01, // Full-client request
                100,  // StartSession event ID
                JSON.stringify(sessionConfig),
                sessionId
            );
            
            ws.send(frame);
            
            // 开始录音
            await startRecording();
            
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            // 开始计时
            startTime = Date.now();
            const timer = setInterval(() => {
                if (!isRecording) {
                    clearInterval(timer);
                    return;
                }
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('duration').textContent = `${elapsed}s`;
            }, 1000);
        }
        
        // 开始录音
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                analyser.smoothingTimeConstant = 0.8;
                analyser.fftSize = 1024;
                
                microphone.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                
                // 音频可视化和数据发送
                let audioChunkCounter = 0;
                scriptProcessor.onaudioprocess = function(event) {
                    const array = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(array);
                    drawVisualizer(array);
                    
                    // 发送音频数据（每隔几个chunk发送一次，避免过于频繁）
                    audioChunkCounter++;
                    if (isRecording && ws && ws.readyState === WebSocket.OPEN && audioChunkCounter % 2 === 0) {
                        const inputBuffer = event.inputBuffer.getChannelData(0);
                        const pcmData = convertFloat32ToPCM16(inputBuffer);
                        
                        // 检查音频数据是否为静音
                        const isQuiet = checkIfQuiet(inputBuffer);
                        console.log(`发送音频块: ${pcmData.length} bytes, 静音: ${isQuiet}`);
                        
                        sendAudioChunk(pcmData);
                    }
                };
                
                isRecording = true;
                updateStatus('recording', '正在录音...');
                
            } catch (err) {
                console.error('无法访问麦克风:', err);
                addMessage('错误', '无法访问麦克风，请检查权限设置', 'error');
            }
        }
        
        // 转换Float32到PCM16
        function convertFloat32ToPCM16(buffer) {
            const length = buffer.length;
            const pcmData = new Int16Array(length);
            
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, buffer[i]));
                pcmData[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            }
            
            return new Uint8Array(pcmData.buffer);
        }
        
        // 检查音频是否为静音
        function checkIfQuiet(buffer) {
            let sum = 0;
            for (let i = 0; i < buffer.length; i++) {
                sum += Math.abs(buffer[i]);
            }
            const average = sum / buffer.length;
            return average < 0.01; // 阈值，低于此值认为是静音
        }
        
        // 发送音频块
        function sendAudioChunk(audioData) {
            if (!ws || ws.readyState !== WebSocket.OPEN || !sessionId) return;
            
            const frame = buildBinaryFrame(
                0x02, // Audio-only request
                200,  // TaskRequest event ID
                audioData,
                sessionId
            );
            
            ws.send(frame);
            sequenceNumber++;
        }
        
        // 停止会话
        function stopSession() {
            isRecording = false;
            isAudioPlaying = false; // 停止音频播放
            
            // 停止录音
            if (microphone) microphone.disconnect();
            if (analyser) analyser.disconnect();
            if (audioContext) audioContext.close();
            
            // 清空音频队列
            audioQueue = [];
            
            // 发送FinishSession事件
            if (ws && ws.readyState === WebSocket.OPEN && sessionId) {
                const frame = buildBinaryFrame(
                    0x01, // Full-client request
                    102,  // FinishSession event ID
                    '{}',
                    sessionId
                );
                ws.send(frame);
            }
            
            updateStatus('connected', '会话已结束');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            // 清空可视化
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // 音频播放相关（按照官方示例使用队列方式）
        let audioQueue = [];
        let isAudioPlaying = false;
        let audioPlaybackContext = null;
        
        // 播放音频（严格按照官方示例处理）
        function playAudio(audioData) {
            console.log(`接收音频数据: ${audioData.length} bytes`);
            
            // 检查当前选择的音频格式
            const audioFormat = document.getElementById('audioFormat').value;
            
            if (audioFormat === 'opus') {
                // Opus格式，累积数据等待完整播放
                accumulateOpusAudio(audioData);
            } else {
                // PCM格式（官方默认），添加到队列立即播放
                audioQueue.push(audioData);
                if (!isAudioPlaying) {
                    startAudioPlayer();
                }
            }
        }
        
        // 启动音频播放线程（模仿官方示例）
        function startAudioPlayer() {
            if (isAudioPlaying) return;
            
            isAudioPlaying = true;
            console.log('启动音频播放线程');
            
            // 初始化音频上下文
            if (!audioPlaybackContext) {
                audioPlaybackContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000
                });
            }
            
            // 启动播放循环
            playNextAudioChunk();
        }
        
        // 播放下一个音频块
        async function playNextAudioChunk() {
            while (isAudioPlaying) {
                if (audioQueue.length > 0) {
                    const audioData = audioQueue.shift();
                    try {
                        await playPCMAudioChunk(audioData);
                    } catch (error) {
                        console.error('音频播放错误:', error);
                        // 尝试备用播放方式
                        showAudioControls(audioData, 'pcm');
                    }
                } else {
                    // 队列为空，等待一小段时间
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
        }
        
        // 播放单个PCM音频块（简化版，按官方逻辑）
        async function playPCMAudioChunk(pcmData) {
            try {
                if (pcmData.length === 0) return;
                
                // 直接使用备用播放方式，创建WAV文件播放
                const wavData = convertPCMToWAV(pcmData);
                const audioBlob = new Blob([wavData], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                const audio = new Audio(audioUrl);
                audio.onloadeddata = () => {
                    console.log(`播放音频块: ${audio.duration?.toFixed(3) || 'unknown'}秒`);
                };
                audio.onerror = (e) => {
                    console.error('音频播放错误:', e);
                };
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                };
                
                // 尝试播放
                try {
                    await audio.play();
                    // 等待播放完成
                    await new Promise(resolve => {
                        audio.onended = resolve;
                    });
                } catch (e) {
                    console.warn('自动播放被阻止，显示播放控件');
                    showAudioControls(pcmData, 'pcm');
                }
                
            } catch (error) {
                console.error('音频块播放错误:', error);
                showAudioControls(pcmData, 'pcm');
            }
        }
        
        // 累积音频数据缓冲区（用于Opus）
        let audioBuffer = new Uint8Array(0);
        let isCollectingAudio = false;
        
        // 累积Opus音频数据（等待TTSEnded事件）
        function accumulateOpusAudio(opusData) {
            try {
                console.log(`累积Opus音频块: ${opusData.length} bytes`);
                
                // 累积音频数据
                const newBuffer = new Uint8Array(audioBuffer.length + opusData.length);
                newBuffer.set(audioBuffer);
                newBuffer.set(opusData, audioBuffer.length);
                audioBuffer = newBuffer;
                
                // 第一次接收时开始收集
                if (!isCollectingAudio) {
                    isCollectingAudio = true;
                    console.log('开始累积Opus音频数据，等待TTSEnded事件...');
                }
                
            } catch (error) {
                console.error('Opus音频累积错误:', error);
                showAudioControls(opusData, 'opus');
            }
        }
        
        // 播放完整的Opus音频（在收到TTSEnded事件时调用）
        function playCompleteOpusAudio() {
            if (!isCollectingAudio || audioBuffer.length === 0) {
                console.log('没有音频数据需要播放');
                return;
            }
            
            try {
                console.log(`播放完整Opus音频: ${audioBuffer.length} bytes`);
                
                // 尝试播放Opus格式音频
                const mimeTypes = [
                    'audio/ogg; codecs=opus',
                    'audio/webm; codecs=opus',
                    'audio/ogg',
                    'audio/webm'
                ];
                
                let audioUrl = null;
                let audio = null;
                
                for (const mimeType of mimeTypes) {
                    try {
                        const audioBlob = new Blob([audioBuffer], { type: mimeType });
                        audioUrl = URL.createObjectURL(audioBlob);
                        audio = new Audio(audioUrl);
                        
                        // 测试是否可以播放
                        const canPlay = audio.canPlayType(mimeType);
                        console.log(`测试MIME类型 ${mimeType}: ${canPlay}`);
                        
                        if (canPlay === 'probably' || canPlay === 'maybe') {
                            console.log(`选择MIME类型: ${mimeType}`);
                            break;
                        } else {
                            URL.revokeObjectURL(audioUrl);
                            audio = null;
                            audioUrl = null;
                        }
                    } catch (e) {
                        console.warn(`MIME类型 ${mimeType} 测试失败:`, e);
                        if (audioUrl) URL.revokeObjectURL(audioUrl);
                        audio = null;
                        audioUrl = null;
                    }
                }
                
                if (!audio || !audioUrl) {
                    console.warn('浏览器不支持Opus格式，显示播放控件');
                    showAudioControls(audioBuffer, 'opus');
                    return;
                }
                
                // 设置音频事件监听器
                audio.onloadedmetadata = () => {
                    console.log(`Opus音频元数据加载完成: 时长=${audio.duration?.toFixed(3) || 'unknown'}秒`);
                };
                
                audio.oncanplaythrough = () => {
                    console.log('Opus音频可以播放');
                };
                
                audio.onended = () => {
                    console.log('完整Opus音频播放完成');
                    URL.revokeObjectURL(audioUrl);
                };
                
                audio.onerror = (e) => {
                    console.error('Opus音频播放错误:', e, audio.error);
                    URL.revokeObjectURL(audioUrl);
                    showAudioControls(audioBuffer, 'opus');
                };
                
                // 尝试播放音频
                console.log('开始播放完整Opus音频...');
                audio.play().then(() => {
                    console.log('Opus音频播放开始成功');
                }).catch(e => {
                    console.error('Opus音频播放开始失败:', e);
                    URL.revokeObjectURL(audioUrl);
                    showAudioControls(audioBuffer, 'opus');
                });
                
            } catch (error) {
                console.error('完整Opus音频处理错误:', error);
                showAudioControls(audioBuffer, 'opus');
            } finally {
                // 重置缓冲区
                audioBuffer = new Uint8Array(0);
                isCollectingAudio = false;
            }
        }
        
        // 移除不需要的队列播放函数
        
        // 显示音频播放控件（备用方案）
        function showAudioControls(audioData, format) {
            const audioControls = document.getElementById('audioControls');
            const audioPlayer = document.getElementById('audioPlayer');
            
            let mimeType;
            if (format === 'opus') {
                mimeType = 'audio/ogg; codecs=opus';
            } else {
                // PCM需要转换为WAV格式
                const wavData = convertPCMToWAV(audioData);
                audioData = wavData;
                mimeType = 'audio/wav';
            }
            
            const audioBlob = new Blob([audioData], { type: mimeType });
            const audioUrl = URL.createObjectURL(audioBlob);
            
            audioPlayer.src = audioUrl;
            audioControls.style.display = 'block';
            
            // 自动播放
            audioPlayer.play().catch(e => {
                console.log('需要用户交互后才能自动播放音频');
            });
            
            // 清理URL
            audioPlayer.onended = () => {
                URL.revokeObjectURL(audioUrl);
                setTimeout(() => {
                    audioControls.style.display = 'none';
                }, 2000);
            };
        }
        
        // 将PCM转换为WAV格式（按照官方配置：Float32格式）
        function convertPCMToWAV(pcmData) {
            const sampleRate = 24000;
            const numChannels = 1;
            const audioFormat = document.getElementById('audioFormat').value;
            
            console.log(`转换音频: 格式=${audioFormat}, 数据长度=${pcmData.length} bytes`);
            
            let samples;
            let bytesPerSample;
            let audioFormatCode;
            
            if (audioFormat === 'pcm_s16le') {
                // 16位整数PCM
                bytesPerSample = 2;
                audioFormatCode = 1; // PCM
                samples = new Int16Array(pcmData.buffer.slice(pcmData.byteOffset, pcmData.byteOffset + pcmData.byteLength));
            } else {
                // 32位浮点PCM (默认，按官方示例)
                bytesPerSample = 4;
                audioFormatCode = 3; // IEEE Float
                samples = new Float32Array(pcmData.buffer.slice(pcmData.byteOffset, pcmData.byteOffset + pcmData.byteLength));
            }
            
            const numSamples = samples.length;
            const dataLength = numSamples * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // WAV文件头
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, audioFormatCode, true); // 1=PCM, 3=IEEE Float
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
            view.setUint16(32, numChannels * bytesPerSample, true);
            view.setUint16(34, bytesPerSample * 8, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            // 复制样本数据
            const wavSampleView = new DataView(buffer, 44);
            
            if (audioFormat === 'pcm_s16le') {
                // 16位整数
                for (let i = 0; i < numSamples; i++) {
                    wavSampleView.setInt16(i * 2, samples[i], true); // little-endian
                }
            } else {
                // 32位浮点
                for (let i = 0; i < numSamples; i++) {
                    wavSampleView.setFloat32(i * 4, samples[i], true); // little-endian
                }
            }
            
            console.log(`WAV转换完成: ${numSamples} 个样本, ${dataLength} 字节数据`);
            
            return buffer;
        }
        
        // 显示ASR结果
        function displayASRResult(text, isInterim) {
            const message = document.createElement('div');
            message.className = 'message user';
            message.innerHTML = `
                ${isInterim ? '[实时]' : '[最终]'} ${text}
                <span class="message-time">${new Date().toLocaleTimeString()}</span>
            `;
            asrResults.appendChild(message);
            asrResults.scrollTop = asrResults.scrollHeight;
        }
        
        // 添加消息
        function addMessage(sender, content, type) {
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.innerHTML = `
                <strong>${sender}:</strong> ${content}
                <span class="message-time">${new Date().toLocaleTimeString()}</span>
            `;
            chatResults.appendChild(message);
            chatResults.scrollTop = chatResults.scrollHeight;
        }
        
        // 绘制音频可视化
        function drawVisualizer(array) {
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / array.length) * 2.5;
            let barHeight;
            let x = 0;
            
            for (let i = 0; i < array.length; i++) {
                barHeight = array[i] / 2;
                
                const gradient = canvasContext.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                
                canvasContext.fillStyle = gradient;
                canvasContext.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        // 清空ASR结果
        function clearASR() {
            asrResults.innerHTML = '';
        }
        
        // 清空聊天记录
        function clearChat() {
            chatResults.innerHTML = '';
        }
        
        // 事件监听器
        connectBtn.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // 断开连接
                if (isRecording) {
                    stopSession();
                }
                
                // 发送FinishConnection事件
                const frame = buildBinaryFrame(0x01, 2, '{}');
                ws.send(frame);
                
                setTimeout(() => {
                    ws.close();
                }, 100);
            } else {
                connectWebSocket();
            }
        });
        
        startBtn.addEventListener('click', startSession);
        stopBtn.addEventListener('click', stopSession);
        
        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
        });
    </script>
</body>
</html>
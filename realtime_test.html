<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è±†åŒ…å®æ—¶è¯­éŸ³å¯¹è¯</title>
    <!-- æ·»åŠ pakoåº“ç”¨äºgzipå‹ç¼© -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .config-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        .config-item {
            flex: 1;
        }

        .config-item label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .config-item input, .config-item select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
        }

        .status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            padding: 15px;
            border-radius: 10px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .status.disconnected {
            background: #ffebee;
            color: #c62828;
        }

        .status.connected {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status.recording {
            background: #fff3e0;
            color: #f57c00;
            animation: pulse 2s infinite;
        }

        .status.processing {
            background: #e3f2fd;
            color: #1976d2;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 150px;
        }

        #connectBtn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        #connectBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.4);
        }

        #startBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #startBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        #stopBtn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            color: white;
        }

        #stopBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(238, 90, 82, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .visualizer {
            width: 100%;
            height: 120px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .results-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            min-height: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .results-title {
            font-size: 14px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clear-btn {
            font-size: 12px;
            padding: 5px 10px;
            background: #e0e0e0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: none;
            letter-spacing: normal;
            min-width: auto;
        }

        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
        }

        .message.user {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .message.assistant {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
        }

        .message.tts {
            background: #fce4ec;
            border-left: 4px solid #e91e63;
        }

        .message.error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
        }

        .message-time {
            font-size: 11px;
            color: #999;
            float: right;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 10px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .audio-controls {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 8px;
        }

        .audio-controls audio {
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤ è±†åŒ…å®æ—¶è¯­éŸ³å¯¹è¯</h1>
        
        <div class="config-panel">
            <div class="config-row">
                <div class="config-item">
                    <label>ä»£ç†æœåŠ¡å™¨çŠ¶æ€</label>
                    <input type="text" id="proxyStatus" value="ä½¿ç”¨æœ¬åœ°ä»£ç† ws://localhost:8765" readonly style="background:#e8f5e8;">
                </div>
                <div class="config-item">
                    <label>è®¤è¯ä¿¡æ¯</label>
                    <input type="text" id="authInfo" value="å·²åœ¨ä»£ç†æœåŠ¡å™¨é…ç½®" readonly style="background:#e8f5e8;">
                </div>
            </div>
            <div class="config-row">
                <div class="config-item">
                    <label>éŸ³è‰²é€‰æ‹©</label>
                    <select id="speaker">
                        <option value="zh_female_vv_jupiter_bigtts">vv (æ´»æ³¼å¥³å£°)</option>
                        <option value="zh_female_xiaohe_jupiter_bigtts">xiaohe (ç”œç¾å¥³å£°)</option>
                        <option value="zh_male_yunzhou_jupiter_bigtts">yunzhou (æ²‰ç¨³ç”·å£°)</option>
                        <option value="zh_male_xiaotian_jupiter_bigtts">xiaotian (ç£æ€§ç”·å£°)</option>
                    </select>
                </div>
                <div class="config-item">
                    <label>è¾“å‡ºæ ¼å¼</label>
                    <select id="audioFormat">
                        <option value="pcm" selected>PCM 24000Hz Float32 (æ¨è)</option>
                        <option value="pcm_s16le">PCM 24000Hz 16bit</option>
                        <option value="opus">Opus</option>
                    </select>
                </div>
            </div>
            <div class="config-row">
                <div class="config-item">
                    <label>æœºå™¨äººåç§°</label>
                    <input type="text" id="botName" value="è±†åŒ…" placeholder="æœºå™¨äººåç§°">
                </div>
                <div class="config-item">
                    <label>å¯¹è¯ ID (å¯é€‰)</label>
                    <input type="text" id="dialogId" placeholder="ç”¨äºç»­æ¥ä¹‹å‰çš„å¯¹è¯">
                </div>
            </div>
        </div>
        
        <div class="status disconnected" id="status">æœªè¿æ¥</div>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="duration">0s</div>
                <div class="stat-label">å¯¹è¯æ—¶é•¿</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="turns">0</div>
                <div class="stat-label">å¯¹è¯è½®æ¬¡</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="tokens">0</div>
                <div class="stat-label">Token ä½¿ç”¨</div>
            </div>
        </div>
        
        <div class="visualizer">
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="connectBtn">è¿æ¥æœåŠ¡</button>
            <button id="startBtn" disabled>å¼€å§‹å¯¹è¯</button>
            <button id="stopBtn" disabled>ç»“æŸå¯¹è¯</button>
        </div>
        
        <div class="results-container">
            <div class="results-panel">
                <div class="results-title">
                    è¯†åˆ«ç»“æœ (ASR)
                    <button class="clear-btn" onclick="clearASR()">æ¸…ç©º</button>
                </div>
                <div id="asr-results"></div>
            </div>
            <div class="results-panel">
                <div class="results-title">
                    å¯¹è¯å†…å®¹ (Chat)
                    <button class="clear-btn" onclick="clearChat()">æ¸…ç©º</button>
                </div>
                <div id="chat-results"></div>
            </div>
        </div>
        
        <div class="audio-controls" style="display:none;" id="audioControls">
            <audio id="audioPlayer" controls></audio>
        </div>
    </div>

    <script>
        // é…ç½®å¸¸é‡
        // ä½¿ç”¨æœ¬åœ°ä»£ç†æœåŠ¡å™¨ï¼ˆä»£ç†æœåŠ¡å™¨ä¼šå¤„ç†è®¤è¯ï¼‰
        const WS_URL = 'ws://localhost:8765';
        const RESOURCE_ID = 'volc.speech.dialog';
        const APP_KEY = 'PlgvMymc7f3tQnJ6';
        
        // WebSocketå’ŒéŸ³é¢‘ç›¸å…³å˜é‡
        let ws = null;
        let audioContext = null;
        let mediaRecorder = null;
        let analyser = null;
        let microphone = null;
        let isRecording = false;
        let sessionId = null;
        let connectId = null;
        let sequenceNumber = 0;
        
        // ç»Ÿè®¡å˜é‡
        let startTime = null;
        let turnCount = 0;
        let totalTokens = 0;
        
        // éŸ³é¢‘ç¼“å†²ï¼ˆç§»é™¤é‡å¤å£°æ˜ï¼‰
        // let audioQueue = []; // å·²åœ¨ä¸‹é¢å£°æ˜
        // let isPlaying = false; // æ”¹åä¸ºisAudioPlaying
        
        // DOM å…ƒç´ 
        const connectBtn = document.getElementById('connectBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusDiv = document.getElementById('status');
        const asrResults = document.getElementById('asr-results');
        const chatResults = document.getElementById('chat-results');
        const canvas = document.getElementById('canvas');
        const canvasContext = canvas.getContext('2d');
        
        // åˆå§‹åŒ–Canvas
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        // ç”ŸæˆUUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // æ›´æ–°çŠ¶æ€
        function updateStatus(statusClass, message) {
            statusDiv.className = `status ${statusClass}`;
            statusDiv.textContent = message;
        }
        
        // å¯¼å…¥pakoåº“ç”¨äºgzipå‹ç¼©ï¼ˆæ·»åŠ åˆ°HTML headéƒ¨åˆ†ï¼‰
        
        // æ„å»ºäºŒè¿›åˆ¶åè®®å¸§ï¼ˆæŒ‰ç…§å®˜æ–¹ç¤ºä¾‹å®ç°ï¼‰
        function buildBinaryFrame(messageType, eventId, payload, sessionIdStr = null) {
            // Header: 4 bytes
            const header = new Uint8Array(4);
            header[0] = 0x11; // Protocol version (0x1) + Header size (0x1)
            header[1] = (messageType << 4) | 0x04; // Message type + event flag
            
            // è®¾ç½®åºåˆ—åŒ–å’Œå‹ç¼©æ–¹å¼ï¼ˆæ ¹æ®å®˜æ–¹ç¤ºä¾‹ï¼‰
            if (typeof payload === 'string') {
                header[2] = 0x11; // JSON serialization + GZIP compression
            } else {
                header[2] = 0x01; // Raw + GZIP compression (éŸ³é¢‘æ•°æ®ä¹Ÿéœ€è¦å‹ç¼©)
            }
            header[3] = 0x00; // Reserved
            
            // Optional fieldsæŒ‰é¡ºåºæ„å»º
            let optional = new Uint8Array(0);
            
            // Event ID (4 bytes)
            const eventBytes = new Uint8Array(4);
            const eventView = new DataView(eventBytes.buffer);
            eventView.setUint32(0, eventId, false); // big-endian
            optional = new Uint8Array([...optional, ...eventBytes]);
            
            // Session ID (å¯¹äºSessionçº§åˆ«çš„äº‹ä»¶)
            if (sessionIdStr && eventId >= 100 && eventId < 600) {
                const sessionBytes = new TextEncoder().encode(sessionIdStr);
                const sizeBytes = new Uint8Array(4);
                const sizeView = new DataView(sizeBytes.buffer);
                sizeView.setUint32(0, sessionBytes.length, false);
                optional = new Uint8Array([...optional, ...sizeBytes, ...sessionBytes]);
            }
            
            // Payloadå¤„ç†å’Œå‹ç¼©
            let payloadBytes;
            if (typeof payload === 'string') {
                // JSONæ•°æ®å…ˆç¼–ç å†å‹ç¼©
                const jsonBytes = new TextEncoder().encode(payload);
                payloadBytes = gzipCompress(jsonBytes);
            } else if (payload instanceof Uint8Array) {
                // éŸ³é¢‘æ•°æ®ä¹Ÿéœ€è¦å‹ç¼©ï¼ˆæŒ‰ç…§å®˜æ–¹ç¤ºä¾‹ï¼‰
                payloadBytes = gzipCompress(payload);
            } else {
                const emptyJson = new TextEncoder().encode('{}');
                payloadBytes = gzipCompress(emptyJson);
            }
            
            // Payload size (4 bytes)
            const payloadSize = new Uint8Array(4);
            const payloadView = new DataView(payloadSize.buffer);
            payloadView.setUint32(0, payloadBytes.length, false);
            
            // Combine all parts
            const result = new Uint8Array([...header, ...optional, ...payloadSize, ...payloadBytes]);
            
            console.log(`æ„å»ºå¸§: æ¶ˆæ¯ç±»å‹=${messageType.toString(16)}, äº‹ä»¶ID=${eventId}, å‹ç¼©åè´Ÿè½½=${payloadBytes.length}bytes, æ€»é•¿åº¦=${result.length}`);
            
            return result;
        }
        
        // ç®€å•çš„gzipå‹ç¼©å®ç°
        function gzipCompress(data) {
            // ä½¿ç”¨pakoåº“è¿›è¡Œgzipå‹ç¼©
            // å¦‚æœæ²¡æœ‰pakoåº“ï¼Œå¯ä»¥å…ˆè¿”å›åŸæ•°æ®ï¼Œä½†è¿™ä¼šå¯¼è‡´åè®®ä¸åŒ¹é…
            if (typeof pako !== 'undefined') {
                return pako.gzip(data);
            } else {
                console.warn('pakoåº“æœªåŠ è½½ï¼Œä½¿ç”¨æœªå‹ç¼©æ•°æ®ï¼ˆå¯èƒ½å¯¼è‡´åè®®é”™è¯¯ï¼‰');
                return data;
            }
        }
        
        // è§£æäºŒè¿›åˆ¶å¸§
        function parseBinaryFrame(data) {
            // ç¡®ä¿dataæ˜¯ArrayBuffer
            let buffer;
            if (data instanceof ArrayBuffer) {
                buffer = data;
            } else if (data.buffer instanceof ArrayBuffer) {
                buffer = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
            } else {
                console.error('Invalid data type for binary frame:', typeof data);
                return null;
            }
            
            const view = new DataView(buffer);
            let offset = 0;
            
            // Parse header
            const byte0 = view.getUint8(offset++);
            const byte1 = view.getUint8(offset++);
            const byte2 = view.getUint8(offset++);
            const byte3 = view.getUint8(offset++);
            
            const messageType = (byte1 >> 4) & 0x0F;
            const flags = byte1 & 0x0F;
            
            // Parse optional fields
            let eventId = null;
            let sessionId = null;
            let errorCode = null;
            
            // Error code (if error frame)
            if (messageType === 0x0F) {
                errorCode = view.getUint32(offset, false);
                offset += 4;
            }
            
            // Event ID
            if (flags & 0x04) {
                eventId = view.getUint32(offset, false);
                offset += 4;
            }
            
            // Session ID
            if (eventId >= 100 && eventId < 600) {
                const sessionIdSize = view.getUint32(offset, false);
                offset += 4;
                const sessionIdBytes = new Uint8Array(data.slice(offset, offset + sessionIdSize));
                sessionId = new TextDecoder().decode(sessionIdBytes);
                offset += sessionIdSize;
            }
            
            // Payload size and payload
            const payloadSize = view.getUint32(offset, false);
            offset += 4;
            
            let payload = null;
            if (payloadSize > 0) {
                const payloadBytes = new Uint8Array(data.slice(offset, offset + payloadSize));
                
                // Check if it's JSON (text) or binary
                if (messageType === 0x09 || messageType === 0x0F) { // Server response or error
                    try {
                        payload = JSON.parse(new TextDecoder().decode(payloadBytes));
                    } catch {
                        payload = payloadBytes;
                    }
                } else if (messageType === 0x0B) { // Audio response
                    payload = payloadBytes;
                }
            }
            
            return {
                messageType,
                flags,
                eventId,
                sessionId,
                errorCode,
                payload
            };
        }
        
        // è¿æ¥WebSocket
        function connectWebSocket() {
            // è¿æ¥åˆ°æœ¬åœ°ä»£ç†æœåŠ¡å™¨ï¼ˆä»£ç†æœåŠ¡å™¨å·²é…ç½®è®¤è¯ä¿¡æ¯ï¼‰
            connectId = generateUUID();
            
            // ç›´æ¥è¿æ¥æœ¬åœ°ä»£ç†
            ws = new WebSocket(WS_URL);
            ws.binaryType = 'arraybuffer';
            
            ws.onopen = () => {
                console.log('WebSocketè¿æ¥å·²å»ºç«‹');
                updateStatus('connected', 'WebSocketå·²è¿æ¥');
                
                // å‘é€StartConnectionäº‹ä»¶
                const frame = buildBinaryFrame(0x01, 1, '{}');
                ws.send(frame);
                
                connectBtn.textContent = 'æ–­å¼€è¿æ¥';
                connectBtn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
                startBtn.disabled = false;
            };
            
            ws.onmessage = (event) => {
                // æ£€æŸ¥æ¶ˆæ¯ç±»å‹
                if (typeof event.data === 'string') {
                    // JSONæ¶ˆæ¯ï¼ˆä»£ç†æœåŠ¡å™¨çš„çŠ¶æ€æ¶ˆæ¯ï¼‰
                    try {
                        const jsonData = JSON.parse(event.data);
                        if (jsonData.type === 'proxy_connected') {
                            console.log('ä»£ç†æœåŠ¡å™¨è¿æ¥ç¡®è®¤:', jsonData.message);
                            addMessage('ç³»ç»Ÿ', jsonData.message, 'assistant');
                        } else if (jsonData.type === 'proxy_error') {
                            console.error('ä»£ç†æœåŠ¡å™¨é”™è¯¯:', jsonData.error);
                            addMessage('é”™è¯¯', jsonData.error, 'error');
                        }
                    } catch (e) {
                        console.error('è§£æJSONæ¶ˆæ¯å¤±è´¥:', e);
                    }
                } else {
                    // äºŒè¿›åˆ¶æ¶ˆæ¯ï¼ˆè±†åŒ…APIæ¶ˆæ¯ï¼‰
                    try {
                        const frame = parseBinaryFrame(event.data);
                        handleServerEvent(frame);
                    } catch (e) {
                        console.error('è§£æäºŒè¿›åˆ¶å¸§å¤±è´¥:', e);
                    }
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocketé”™è¯¯:', error);
                updateStatus('disconnected', 'WebSocketé”™è¯¯');
            };
            
            ws.onclose = () => {
                console.log('WebSocketè¿æ¥å·²å…³é—­');
                updateStatus('disconnected', 'è¿æ¥å·²æ–­å¼€');
                connectBtn.textContent = 'è¿æ¥æœåŠ¡';
                connectBtn.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
                startBtn.disabled = true;
                stopBtn.disabled = true;
                ws = null;
            };
        }
        
        // å¤„ç†æœåŠ¡å™¨äº‹ä»¶ï¼ˆæŒ‰ç…§å®˜æ–¹ç¤ºä¾‹é€»è¾‘ï¼‰
        function handleServerEvent(frame) {
            if (!frame) {
                console.warn('æ¥æ”¶åˆ°æ— æ•ˆçš„å¸§æ•°æ®');
                return;
            }
            
            const { eventId, payload, messageType } = frame;
            
            console.log('æ”¶åˆ°äº‹ä»¶: messageType=', messageType?.toString(16), 'eventId=', eventId);
            
            // æŒ‰ç…§å®˜æ–¹ç¤ºä¾‹ï¼šéŸ³é¢‘æ•°æ®æ˜¯SERVER_ACKç±»å‹ï¼ˆmessageType = 0x0Bï¼‰
            if (messageType === 0x0B && payload instanceof Uint8Array) {
                // è¿™æ˜¯éŸ³é¢‘æ•°æ®ï¼ç›´æ¥æ’­æ”¾
                console.log(`æ¥æ”¶åˆ°éŸ³é¢‘æ•°æ®: ${payload.length} å­—èŠ‚`);
                playAudio(payload);
                return;
            }
            
            // å¤„ç†å…¶ä»–äº‹ä»¶
            switch (eventId) {
                case 50: // ConnectionStarted
                    addMessage('ç³»ç»Ÿ', 'è¿æ¥å·²å»ºç«‹', 'assistant');
                    break;
                    
                case 450: // ASRInfo - ç”¨æˆ·å¼€å§‹è¯´è¯ï¼Œæ¸…ç©ºéŸ³é¢‘ç¼“å­˜
                    console.log('æ£€æµ‹åˆ°ç”¨æˆ·è¯´è¯ï¼Œæ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—');
                    audioQueue = []; // æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—
                    updateStatus('processing', 'æ£€æµ‹åˆ°è¯­éŸ³');
                    break;
                    
                case 150: // SessionStarted
                    if (payload && payload.dialog_id) {
                        document.getElementById('dialogId').value = payload.dialog_id;
                    }
                    updateStatus('connected', 'ä¼šè¯å·²å¼€å§‹');
                    addMessage('ç³»ç»Ÿ', 'ä¼šè¯å·²å¼€å§‹', 'assistant');
                    break;
                    
                case 451: // ASRResponse
                    if (payload && payload.results && payload.results.length > 0) {
                        const result = payload.results[0];
                        displayASRResult(result.text, result.is_interim);
                    }
                    break;
                    
                case 459: // ASREnded
                    updateStatus('processing', 'è¯­éŸ³ç»“æŸï¼Œç­‰å¾…å›å¤...');
                    break;
                    
                case 350: // TTSSentenceStart
                    if (payload && payload.text) {
                        addMessage('è±†åŒ…', payload.text, 'assistant');
                    }
                    break;
                    
                case 359: // TTSEnded
                    turnCount++;
                    document.getElementById('turns').textContent = turnCount;
                    updateStatus('recording', 'ç­‰å¾…æ‚¨è¯´è¯...');
                    
                    // æ ¹æ®æ ¼å¼æ’­æ”¾ç´¯ç§¯çš„éŸ³é¢‘
                    const currentFormat = document.getElementById('audioFormat').value;
                    if (currentFormat === 'opus' && isCollectingAudio) {
                        playCompleteOpusAudio();
                    }
                    break;
                    
                case 550: // ChatResponse
                    if (payload && payload.content) {
                        addMessage('è±†åŒ…', payload.content, 'assistant');
                    }
                    break;
                    
                case 154: // UsageResponse
                    if (payload && payload.usage) {
                        const usage = payload.usage;
                        const total = (usage.input_text_tokens || 0) + 
                                     (usage.input_audio_tokens || 0) + 
                                     (usage.output_text_tokens || 0) + 
                                     (usage.output_audio_tokens || 0);
                        totalTokens += total;
                        document.getElementById('tokens').textContent = totalTokens;
                    }
                    break;
                    
                case 153: // SessionFailed
                case 51: // ConnectionFailed
                    if (payload && payload.error) {
                        addMessage('é”™è¯¯', payload.error, 'error');
                    }
                    break;
            }
        }
        
        // å¼€å§‹ä¼šè¯
        async function startSession() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('è¯·å…ˆè¿æ¥WebSocket');
                return;
            }
            
            sessionId = generateUUID();
            
            // æ„å»ºStartSession payload
            const speaker = document.getElementById('speaker').value;
            const audioFormat = document.getElementById('audioFormat').value;
            const botName = document.getElementById('botName').value;
            const dialogId = document.getElementById('dialogId').value;
            
            // æŒ‰ç…§å®˜æ–¹ç¤ºä¾‹é…ç½®ï¼ˆå®Œæ•´é…ç½®ï¼‰
            const sessionConfig = {
                asr: {
                    extra: {
                        end_smooth_window_ms: 1500
                    }
                },
                tts: {
                    speaker: speaker,
                    audio_config: {
                        channel: 1,
                        format: audioFormat,
                        sample_rate: 24000
                    }
                },
                dialog: {
                    bot_name: botName || 'è±†åŒ…',
                    system_role: 'ä½ ä½¿ç”¨æ´»æ³¼çµåŠ¨çš„å¥³å£°ï¼Œæ€§æ ¼å¼€æœ—ï¼Œçƒ­çˆ±ç”Ÿæ´»ã€‚',
                    speaking_style: 'ä½ çš„è¯´è¯é£æ ¼ç®€æ´æ˜äº†ï¼Œè¯­é€Ÿé€‚ä¸­ï¼Œè¯­è°ƒè‡ªç„¶ã€‚',
                    location: {
                        city: 'åŒ—äº¬'
                    },
                    extra: {
                        strict_audit: false,
                        audit_response: 'æ”¯æŒå®¢æˆ·è‡ªå®šä¹‰å®‰å…¨å®¡æ ¸å›å¤è¯æœ¯ã€‚'
                    }
                }
            };
            
            // å¦‚æœæœ‰dialog_idï¼Œæ·»åŠ åˆ°é…ç½®ä¸­
            if (dialogId) {
                sessionConfig.dialog.dialog_id = dialogId;
            }
            
            // å‘é€StartSessionäº‹ä»¶
            const frame = buildBinaryFrame(
                0x01, // Full-client request
                100,  // StartSession event ID
                JSON.stringify(sessionConfig),
                sessionId
            );
            
            ws.send(frame);
            
            // å¼€å§‹å½•éŸ³
            await startRecording();
            
            startBtn.disabled = true;
            stopBtn.disabled = false;
            
            // å¼€å§‹è®¡æ—¶
            startTime = Date.now();
            const timer = setInterval(() => {
                if (!isRecording) {
                    clearInterval(timer);
                    return;
                }
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('duration').textContent = `${elapsed}s`;
            }, 1000);
        }
        
        // å¼€å§‹å½•éŸ³
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                const scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
                
                analyser.smoothingTimeConstant = 0.8;
                analyser.fftSize = 1024;
                
                microphone.connect(analyser);
                analyser.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                
                // éŸ³é¢‘å¯è§†åŒ–å’Œæ•°æ®å‘é€
                let audioChunkCounter = 0;
                scriptProcessor.onaudioprocess = function(event) {
                    const array = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(array);
                    drawVisualizer(array);
                    
                    // å‘é€éŸ³é¢‘æ•°æ®ï¼ˆæ¯éš”å‡ ä¸ªchunkå‘é€ä¸€æ¬¡ï¼Œé¿å…è¿‡äºé¢‘ç¹ï¼‰
                    audioChunkCounter++;
                    if (isRecording && ws && ws.readyState === WebSocket.OPEN && audioChunkCounter % 2 === 0) {
                        const inputBuffer = event.inputBuffer.getChannelData(0);
                        const pcmData = convertFloat32ToPCM16(inputBuffer);
                        
                        // æ£€æŸ¥éŸ³é¢‘æ•°æ®æ˜¯å¦ä¸ºé™éŸ³
                        const isQuiet = checkIfQuiet(inputBuffer);
                        console.log(`å‘é€éŸ³é¢‘å—: ${pcmData.length} bytes, é™éŸ³: ${isQuiet}`);
                        
                        sendAudioChunk(pcmData);
                    }
                };
                
                isRecording = true;
                updateStatus('recording', 'æ­£åœ¨å½•éŸ³...');
                
            } catch (err) {
                console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', err);
                addMessage('é”™è¯¯', 'æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®', 'error');
            }
        }
        
        // è½¬æ¢Float32åˆ°PCM16
        function convertFloat32ToPCM16(buffer) {
            const length = buffer.length;
            const pcmData = new Int16Array(length);
            
            for (let i = 0; i < length; i++) {
                const sample = Math.max(-1, Math.min(1, buffer[i]));
                pcmData[i] = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            }
            
            return new Uint8Array(pcmData.buffer);
        }
        
        // æ£€æŸ¥éŸ³é¢‘æ˜¯å¦ä¸ºé™éŸ³
        function checkIfQuiet(buffer) {
            let sum = 0;
            for (let i = 0; i < buffer.length; i++) {
                sum += Math.abs(buffer[i]);
            }
            const average = sum / buffer.length;
            return average < 0.01; // é˜ˆå€¼ï¼Œä½äºæ­¤å€¼è®¤ä¸ºæ˜¯é™éŸ³
        }
        
        // å‘é€éŸ³é¢‘å—
        function sendAudioChunk(audioData) {
            if (!ws || ws.readyState !== WebSocket.OPEN || !sessionId) return;
            
            const frame = buildBinaryFrame(
                0x02, // Audio-only request
                200,  // TaskRequest event ID
                audioData,
                sessionId
            );
            
            ws.send(frame);
            sequenceNumber++;
        }
        
        // åœæ­¢ä¼šè¯
        function stopSession() {
            isRecording = false;
            isAudioPlaying = false; // åœæ­¢éŸ³é¢‘æ’­æ”¾
            
            // åœæ­¢å½•éŸ³
            if (microphone) microphone.disconnect();
            if (analyser) analyser.disconnect();
            if (audioContext) audioContext.close();
            
            // æ¸…ç©ºéŸ³é¢‘é˜Ÿåˆ—
            audioQueue = [];
            
            // å‘é€FinishSessionäº‹ä»¶
            if (ws && ws.readyState === WebSocket.OPEN && sessionId) {
                const frame = buildBinaryFrame(
                    0x01, // Full-client request
                    102,  // FinishSession event ID
                    '{}',
                    sessionId
                );
                ws.send(frame);
            }
            
            updateStatus('connected', 'ä¼šè¯å·²ç»“æŸ');
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            // æ¸…ç©ºå¯è§†åŒ–
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // éŸ³é¢‘æ’­æ”¾ç›¸å…³ï¼ˆæŒ‰ç…§å®˜æ–¹ç¤ºä¾‹ä½¿ç”¨é˜Ÿåˆ—æ–¹å¼ï¼‰
        let audioQueue = [];
        let isAudioPlaying = false;
        let audioPlaybackContext = null;
        
        // æ’­æ”¾éŸ³é¢‘ï¼ˆä¸¥æ ¼æŒ‰ç…§å®˜æ–¹ç¤ºä¾‹å¤„ç†ï¼‰
        function playAudio(audioData) {
            console.log(`æ¥æ”¶éŸ³é¢‘æ•°æ®: ${audioData.length} bytes`);
            
            // æ£€æŸ¥å½“å‰é€‰æ‹©çš„éŸ³é¢‘æ ¼å¼
            const audioFormat = document.getElementById('audioFormat').value;
            
            if (audioFormat === 'opus') {
                // Opusæ ¼å¼ï¼Œç´¯ç§¯æ•°æ®ç­‰å¾…å®Œæ•´æ’­æ”¾
                accumulateOpusAudio(audioData);
            } else {
                // PCMæ ¼å¼ï¼ˆå®˜æ–¹é»˜è®¤ï¼‰ï¼Œæ·»åŠ åˆ°é˜Ÿåˆ—ç«‹å³æ’­æ”¾
                audioQueue.push(audioData);
                if (!isAudioPlaying) {
                    startAudioPlayer();
                }
            }
        }
        
        // å¯åŠ¨éŸ³é¢‘æ’­æ”¾çº¿ç¨‹ï¼ˆæ¨¡ä»¿å®˜æ–¹ç¤ºä¾‹ï¼‰
        function startAudioPlayer() {
            if (isAudioPlaying) return;
            
            isAudioPlaying = true;
            console.log('å¯åŠ¨éŸ³é¢‘æ’­æ”¾çº¿ç¨‹');
            
            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (!audioPlaybackContext) {
                audioPlaybackContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000
                });
            }
            
            // å¯åŠ¨æ’­æ”¾å¾ªç¯
            playNextAudioChunk();
        }
        
        // æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘å—
        async function playNextAudioChunk() {
            while (isAudioPlaying) {
                if (audioQueue.length > 0) {
                    const audioData = audioQueue.shift();
                    try {
                        await playPCMAudioChunk(audioData);
                    } catch (error) {
                        console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', error);
                        // å°è¯•å¤‡ç”¨æ’­æ”¾æ–¹å¼
                        showAudioControls(audioData, 'pcm');
                    }
                } else {
                    // é˜Ÿåˆ—ä¸ºç©ºï¼Œç­‰å¾…ä¸€å°æ®µæ—¶é—´
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
        }
        
        // æ’­æ”¾å•ä¸ªPCMéŸ³é¢‘å—ï¼ˆç®€åŒ–ç‰ˆï¼ŒæŒ‰å®˜æ–¹é€»è¾‘ï¼‰
        async function playPCMAudioChunk(pcmData) {
            try {
                if (pcmData.length === 0) return;
                
                // ç›´æ¥ä½¿ç”¨å¤‡ç”¨æ’­æ”¾æ–¹å¼ï¼Œåˆ›å»ºWAVæ–‡ä»¶æ’­æ”¾
                const wavData = convertPCMToWAV(pcmData);
                const audioBlob = new Blob([wavData], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(audioBlob);
                
                const audio = new Audio(audioUrl);
                audio.onloadeddata = () => {
                    console.log(`æ’­æ”¾éŸ³é¢‘å—: ${audio.duration?.toFixed(3) || 'unknown'}ç§’`);
                };
                audio.onerror = (e) => {
                    console.error('éŸ³é¢‘æ’­æ”¾é”™è¯¯:', e);
                };
                audio.onended = () => {
                    URL.revokeObjectURL(audioUrl);
                };
                
                // å°è¯•æ’­æ”¾
                try {
                    await audio.play();
                    // ç­‰å¾…æ’­æ”¾å®Œæˆ
                    await new Promise(resolve => {
                        audio.onended = resolve;
                    });
                } catch (e) {
                    console.warn('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œæ˜¾ç¤ºæ’­æ”¾æ§ä»¶');
                    showAudioControls(pcmData, 'pcm');
                }
                
            } catch (error) {
                console.error('éŸ³é¢‘å—æ’­æ”¾é”™è¯¯:', error);
                showAudioControls(pcmData, 'pcm');
            }
        }
        
        // ç´¯ç§¯éŸ³é¢‘æ•°æ®ç¼“å†²åŒºï¼ˆç”¨äºOpusï¼‰
        let audioBuffer = new Uint8Array(0);
        let isCollectingAudio = false;
        
        // ç´¯ç§¯OpuséŸ³é¢‘æ•°æ®ï¼ˆç­‰å¾…TTSEndedäº‹ä»¶ï¼‰
        function accumulateOpusAudio(opusData) {
            try {
                console.log(`ç´¯ç§¯OpuséŸ³é¢‘å—: ${opusData.length} bytes`);
                
                // ç´¯ç§¯éŸ³é¢‘æ•°æ®
                const newBuffer = new Uint8Array(audioBuffer.length + opusData.length);
                newBuffer.set(audioBuffer);
                newBuffer.set(opusData, audioBuffer.length);
                audioBuffer = newBuffer;
                
                // ç¬¬ä¸€æ¬¡æ¥æ”¶æ—¶å¼€å§‹æ”¶é›†
                if (!isCollectingAudio) {
                    isCollectingAudio = true;
                    console.log('å¼€å§‹ç´¯ç§¯OpuséŸ³é¢‘æ•°æ®ï¼Œç­‰å¾…TTSEndedäº‹ä»¶...');
                }
                
            } catch (error) {
                console.error('OpuséŸ³é¢‘ç´¯ç§¯é”™è¯¯:', error);
                showAudioControls(opusData, 'opus');
            }
        }
        
        // æ’­æ”¾å®Œæ•´çš„OpuséŸ³é¢‘ï¼ˆåœ¨æ”¶åˆ°TTSEndedäº‹ä»¶æ—¶è°ƒç”¨ï¼‰
        function playCompleteOpusAudio() {
            if (!isCollectingAudio || audioBuffer.length === 0) {
                console.log('æ²¡æœ‰éŸ³é¢‘æ•°æ®éœ€è¦æ’­æ”¾');
                return;
            }
            
            try {
                console.log(`æ’­æ”¾å®Œæ•´OpuséŸ³é¢‘: ${audioBuffer.length} bytes`);
                
                // å°è¯•æ’­æ”¾Opusæ ¼å¼éŸ³é¢‘
                const mimeTypes = [
                    'audio/ogg; codecs=opus',
                    'audio/webm; codecs=opus',
                    'audio/ogg',
                    'audio/webm'
                ];
                
                let audioUrl = null;
                let audio = null;
                
                for (const mimeType of mimeTypes) {
                    try {
                        const audioBlob = new Blob([audioBuffer], { type: mimeType });
                        audioUrl = URL.createObjectURL(audioBlob);
                        audio = new Audio(audioUrl);
                        
                        // æµ‹è¯•æ˜¯å¦å¯ä»¥æ’­æ”¾
                        const canPlay = audio.canPlayType(mimeType);
                        console.log(`æµ‹è¯•MIMEç±»å‹ ${mimeType}: ${canPlay}`);
                        
                        if (canPlay === 'probably' || canPlay === 'maybe') {
                            console.log(`é€‰æ‹©MIMEç±»å‹: ${mimeType}`);
                            break;
                        } else {
                            URL.revokeObjectURL(audioUrl);
                            audio = null;
                            audioUrl = null;
                        }
                    } catch (e) {
                        console.warn(`MIMEç±»å‹ ${mimeType} æµ‹è¯•å¤±è´¥:`, e);
                        if (audioUrl) URL.revokeObjectURL(audioUrl);
                        audio = null;
                        audioUrl = null;
                    }
                }
                
                if (!audio || !audioUrl) {
                    console.warn('æµè§ˆå™¨ä¸æ”¯æŒOpusæ ¼å¼ï¼Œæ˜¾ç¤ºæ’­æ”¾æ§ä»¶');
                    showAudioControls(audioBuffer, 'opus');
                    return;
                }
                
                // è®¾ç½®éŸ³é¢‘äº‹ä»¶ç›‘å¬å™¨
                audio.onloadedmetadata = () => {
                    console.log(`OpuséŸ³é¢‘å…ƒæ•°æ®åŠ è½½å®Œæˆ: æ—¶é•¿=${audio.duration?.toFixed(3) || 'unknown'}ç§’`);
                };
                
                audio.oncanplaythrough = () => {
                    console.log('OpuséŸ³é¢‘å¯ä»¥æ’­æ”¾');
                };
                
                audio.onended = () => {
                    console.log('å®Œæ•´OpuséŸ³é¢‘æ’­æ”¾å®Œæˆ');
                    URL.revokeObjectURL(audioUrl);
                };
                
                audio.onerror = (e) => {
                    console.error('OpuséŸ³é¢‘æ’­æ”¾é”™è¯¯:', e, audio.error);
                    URL.revokeObjectURL(audioUrl);
                    showAudioControls(audioBuffer, 'opus');
                };
                
                // å°è¯•æ’­æ”¾éŸ³é¢‘
                console.log('å¼€å§‹æ’­æ”¾å®Œæ•´OpuséŸ³é¢‘...');
                audio.play().then(() => {
                    console.log('OpuséŸ³é¢‘æ’­æ”¾å¼€å§‹æˆåŠŸ');
                }).catch(e => {
                    console.error('OpuséŸ³é¢‘æ’­æ”¾å¼€å§‹å¤±è´¥:', e);
                    URL.revokeObjectURL(audioUrl);
                    showAudioControls(audioBuffer, 'opus');
                });
                
            } catch (error) {
                console.error('å®Œæ•´OpuséŸ³é¢‘å¤„ç†é”™è¯¯:', error);
                showAudioControls(audioBuffer, 'opus');
            } finally {
                // é‡ç½®ç¼“å†²åŒº
                audioBuffer = new Uint8Array(0);
                isCollectingAudio = false;
            }
        }
        
        // ç§»é™¤ä¸éœ€è¦çš„é˜Ÿåˆ—æ’­æ”¾å‡½æ•°
        
        // æ˜¾ç¤ºéŸ³é¢‘æ’­æ”¾æ§ä»¶ï¼ˆå¤‡ç”¨æ–¹æ¡ˆï¼‰
        function showAudioControls(audioData, format) {
            const audioControls = document.getElementById('audioControls');
            const audioPlayer = document.getElementById('audioPlayer');
            
            let mimeType;
            if (format === 'opus') {
                mimeType = 'audio/ogg; codecs=opus';
            } else {
                // PCMéœ€è¦è½¬æ¢ä¸ºWAVæ ¼å¼
                const wavData = convertPCMToWAV(audioData);
                audioData = wavData;
                mimeType = 'audio/wav';
            }
            
            const audioBlob = new Blob([audioData], { type: mimeType });
            const audioUrl = URL.createObjectURL(audioBlob);
            
            audioPlayer.src = audioUrl;
            audioControls.style.display = 'block';
            
            // è‡ªåŠ¨æ’­æ”¾
            audioPlayer.play().catch(e => {
                console.log('éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½è‡ªåŠ¨æ’­æ”¾éŸ³é¢‘');
            });
            
            // æ¸…ç†URL
            audioPlayer.onended = () => {
                URL.revokeObjectURL(audioUrl);
                setTimeout(() => {
                    audioControls.style.display = 'none';
                }, 2000);
            };
        }
        
        // å°†PCMè½¬æ¢ä¸ºWAVæ ¼å¼ï¼ˆæŒ‰ç…§å®˜æ–¹é…ç½®ï¼šFloat32æ ¼å¼ï¼‰
        function convertPCMToWAV(pcmData) {
            const sampleRate = 24000;
            const numChannels = 1;
            const audioFormat = document.getElementById('audioFormat').value;
            
            console.log(`è½¬æ¢éŸ³é¢‘: æ ¼å¼=${audioFormat}, æ•°æ®é•¿åº¦=${pcmData.length} bytes`);
            
            let samples;
            let bytesPerSample;
            let audioFormatCode;
            
            if (audioFormat === 'pcm_s16le') {
                // 16ä½æ•´æ•°PCM
                bytesPerSample = 2;
                audioFormatCode = 1; // PCM
                samples = new Int16Array(pcmData.buffer.slice(pcmData.byteOffset, pcmData.byteOffset + pcmData.byteLength));
            } else {
                // 32ä½æµ®ç‚¹PCM (é»˜è®¤ï¼ŒæŒ‰å®˜æ–¹ç¤ºä¾‹)
                bytesPerSample = 4;
                audioFormatCode = 3; // IEEE Float
                samples = new Float32Array(pcmData.buffer.slice(pcmData.byteOffset, pcmData.byteOffset + pcmData.byteLength));
            }
            
            const numSamples = samples.length;
            const dataLength = numSamples * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // WAVæ–‡ä»¶å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(8, 'WAVE');
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, audioFormatCode, true); // 1=PCM, 3=IEEE Float
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
            view.setUint16(32, numChannels * bytesPerSample, true);
            view.setUint16(34, bytesPerSample * 8, true);
            writeString(36, 'data');
            view.setUint32(40, dataLength, true);
            
            // å¤åˆ¶æ ·æœ¬æ•°æ®
            const wavSampleView = new DataView(buffer, 44);
            
            if (audioFormat === 'pcm_s16le') {
                // 16ä½æ•´æ•°
                for (let i = 0; i < numSamples; i++) {
                    wavSampleView.setInt16(i * 2, samples[i], true); // little-endian
                }
            } else {
                // 32ä½æµ®ç‚¹
                for (let i = 0; i < numSamples; i++) {
                    wavSampleView.setFloat32(i * 4, samples[i], true); // little-endian
                }
            }
            
            console.log(`WAVè½¬æ¢å®Œæˆ: ${numSamples} ä¸ªæ ·æœ¬, ${dataLength} å­—èŠ‚æ•°æ®`);
            
            return buffer;
        }
        
        // æ˜¾ç¤ºASRç»“æœ
        function displayASRResult(text, isInterim) {
            const message = document.createElement('div');
            message.className = 'message user';
            message.innerHTML = `
                ${isInterim ? '[å®æ—¶]' : '[æœ€ç»ˆ]'} ${text}
                <span class="message-time">${new Date().toLocaleTimeString()}</span>
            `;
            asrResults.appendChild(message);
            asrResults.scrollTop = asrResults.scrollHeight;
        }
        
        // æ·»åŠ æ¶ˆæ¯
        function addMessage(sender, content, type) {
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.innerHTML = `
                <strong>${sender}:</strong> ${content}
                <span class="message-time">${new Date().toLocaleTimeString()}</span>
            `;
            chatResults.appendChild(message);
            chatResults.scrollTop = chatResults.scrollHeight;
        }
        
        // ç»˜åˆ¶éŸ³é¢‘å¯è§†åŒ–
        function drawVisualizer(array) {
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);
            
            const barWidth = (canvas.width / array.length) * 2.5;
            let barHeight;
            let x = 0;
            
            for (let i = 0; i < array.length; i++) {
                barHeight = array[i] / 2;
                
                const gradient = canvasContext.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');
                
                canvasContext.fillStyle = gradient;
                canvasContext.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                
                x += barWidth + 1;
            }
        }
        
        // æ¸…ç©ºASRç»“æœ
        function clearASR() {
            asrResults.innerHTML = '';
        }
        
        // æ¸…ç©ºèŠå¤©è®°å½•
        function clearChat() {
            chatResults.innerHTML = '';
        }
        
        // äº‹ä»¶ç›‘å¬å™¨
        connectBtn.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                // æ–­å¼€è¿æ¥
                if (isRecording) {
                    stopSession();
                }
                
                // å‘é€FinishConnectionäº‹ä»¶
                const frame = buildBinaryFrame(0x01, 2, '{}');
                ws.send(frame);
                
                setTimeout(() => {
                    ws.close();
                }, 100);
            } else {
                connectWebSocket();
            }
        });
        
        startBtn.addEventListener('click', startSession);
        stopBtn.addEventListener('click', stopSession);
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
        });
    </script>
</body>
</html>